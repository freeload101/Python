import json
import requests
import time
import array  
import yaml

# for async
import asyncio
import logging

# for command line args
import sys

# get the byte size of a vars
from sys import getsizeof


# for file mamagment backup of JSON output etc..
import shutil

# for skipping cert errors in proxy 
import ssl

# for setting OS env vars for proxy
import os

# for checking for files existing
import pathlib

# for counting dupes  

############################################################ NOTES

'''

#[] is for indexing
#() is for calling that function
# time.sleep( 5 )
# Brackets ([and ]) delineate the start and stop of a JSON list. Lists require numeric indexes. â€“
#time.sleep( 2 )

# json_str = json.dumps(data, indent=4)
#VAR_AIDS_TRY1 = {'hostname':(tok_dict['resources'][0]['hostname']),'device_id':(tok_dict['resources'][0]['device_id']) }
# asyncio.create_task
# 3.7 asyncio.run
# asyncio.gather
# async with ClientSession

#default = ('python', 'programming', 'compsci')
#keys = sys.argv[1:] if len(sys.argv) > 1 else default

'''
############################################################ CONFIG

yaml.warnings({'YAMLLoadWarning': False})

Loader=yaml.FullLoader
with open("config.yml", 'r') as ymlfile:
    cfg = yaml.load(ymlfile, Loader=yaml.FullLoader)
#print(cfg['client_id'])

VAR_CLIENT_ID=(cfg['client_id'])
VAR_CLIENT_SECRET=(cfg['client_secret'])



# CREATE DATA TIME VARIABLE
datetime_var = time.strftime("__%d_%m_%y-%H-%M")


############################################################ FUNCTIONS

def FUNC_BACKUP():
    
    # CREATE DATA TIME VARIABLE
    if pathlib.Path("r_data.json").exists ():
        datetime_var = time.strftime("__%d_%m_%y-%H-%M")    
        print("DEBUG: Backing up r_data.json to: " "r_data.json"+str(datetime_var))
        shutil.move("r_data.json", "r_data.json"+str(datetime_var))
    
def FUNC_DEBUG():
    print("DEBUG:", 
    "VAR_AID_RUNS_NEEDED:",VAR_AID_RUNS_NEEDED,
    "VAR_OFFSET_CURRENT:",VAR_OFFSET_CURRENT,
    "len(VAR_AIDS_ARRAY):",len(VAR_AIDS_ARRAY),
    "len(VAR_AIDS):",len(VAR_AIDS),
    "type(VAR_AIDS):",type(VAR_AIDS),
    )

def list_duplicates(seq):
  seen = set()
  seen_add = seen.add
  # adds all elements it doesn't know yet to seen and all other to seen_twice
  seen_twice = set( x for x in seq if x in seen or seen_add(x) )
  # turn the set into a list (as requested)
  return list( seen_twice )

################################################################################ INIT

# backup JSON file 
FUNC_BACKUP()


# verify ssl flag set to True so you dont get warnings
VAR_SSL_FLAG=True

# proxy setup
#os.environ["HTTP_PROXY"] = "http://127.0.0.1:8080"
# os.environ["HTTPS_PROXY"] = "http://127.0.0.1:8080"
# VAR_SSL_FLAG=False


 

################################################################################ AUTH
# get Oauth Access Bearer Token...
r = requests.post('https://api.crowdstrike.com/oauth2/token', data = {'client_id':VAR_CLIENT_ID,'client_secret':VAR_CLIENT_SECRET},verify=VAR_SSL_FLAG)
if r.status_code in [201]:
    #print("DEBUG: Status 201 OK!")
    tok_dict = json.loads(r.text)
    access_token = tok_dict["access_token"]
    print("DEBUG: Access Token is "+access_token)
else:
    print(r.status_code)
    print(r.url)
    print(r.text)
    print(r.content)
    print("ERROR DID NOT GET 201 STATUS CODE") 


################################################################################ GET TOTAL COUNT OF AIDS
r = requests.get('https://api.crowdstrike.com/devices/queries/devices/v1?limit=2&sort=first_seen.desc&offset=0', headers = {'Authorization': 'Bearer ' + access_token},verify=VAR_SSL_FLAG)
tok_dict = json.loads(r.text)
VAR_TOTAL = (tok_dict['meta']['pagination']['total'])

print("DEBUG: Total AIDs ",VAR_TOTAL)

VAR_AID_RUNS_NEEDED=(VAR_TOTAL/5000)

print("DEBUG: Total runs needed for all AIDs ",VAR_AID_RUNS_NEEDED)


VAR_AIDS_ARRAY=[]
VAR_AIDS=[]
VAR_OFFSET_CURRENT=0
count = 0


################################################################################ GET ALL THE AIDS
while count < VAR_AID_RUNS_NEEDED:
    r = requests.get("https://api.crowdstrike.com/devices/queries/devices/v1?limit=5000&sort=first_seen.desc", headers = {'Authorization': 'Bearer ' + access_token}, params = {'offset':VAR_OFFSET_CURRENT},verify=VAR_SSL_FLAG)
    print("DEBUG: Fetching chunks",r.url)
    tok_dict = r.json()
    VAR_AIDS = (tok_dict['resources'])
    VAR_OFFSET_CURRENT += 5000
    count += 1
    # DEBUG set count to += 4
    for i in VAR_AIDS:
        VAR_AIDS_ARRAY.append(i)

  


VAR_CHUNKS = [VAR_AIDS_ARRAY[i:i + 500] for i in range(0,len(VAR_AIDS_ARRAY), 500)]

print("DEBUG: Splitting "+str(len(VAR_AIDS_ARRAY))+" AIDS into 500 count ")

VAR_CHUNKS_ALL_LIST=[]

for i in VAR_CHUNKS:
    VAR_CHUNKS_TOTAL= (len(VAR_CHUNKS))
    VAR_CHUNKS_TMP = ""
    for j in i:
        VAR_CHUNKS_TMP += str(j) + "&ids="
    VAR_CHUNKS_ALL_LIST.append(VAR_CHUNKS_TMP[:-5])

VAR_AIDS_DETAIL=[]
VAR_AIDS_DETAIL_LIST=[]

 

for i in VAR_CHUNKS_ALL_LIST:
    r = requests.get("https://api.crowdstrike.com/devices/entities/devices/v1?ids="+str(i), headers = {'Authorization': 'Bearer ' + access_token},verify=VAR_SSL_FLAG)
    r_data = json.loads(r.text)
    print("DEBUG: Fetching",len(VAR_AIDS_DETAIL_LIST),"ids of",len(VAR_AIDS_ARRAY))
    
    # output to broken json file
    with open('r_data.json', 'a+') as outfile1:
            json.dump(r_data, outfile1, indent=4)

    for i in range (len(r_data['resources'])):
        # we had at least one AID without a hostname ... WTF...
        #VAR_CURRENT_HOSTNAME=(r_data.get['resources'])
        ################################################  python "KeyError:" catch #### fix aid missing hostenams using .get
        VAR_CURRENT_HOSTNAME=(r_data['resources'][i]['hostname'])
        VAR_CURRENT_DEVICE_ID=(r_data['resources'][i]['device_id'])
        VAR_CURRENT_LAST_SEEN=(r_data['resources'][i]['last_seen'])

        #print(VAR_CURRENT_HOSTNAME,VAR_CURRENT_DEVICE_ID,VAR_CURRENT_LAST_SEEN)
        VAR_AIDS_DETAIL_LIST.append([VAR_CURRENT_HOSTNAME,VAR_CURRENT_DEVICE_ID,VAR_CURRENT_LAST_SEEN])


######################################################### GET DUPE HOSTNAMES 
VAR_AIDS_DETAIL_LIST_HOSTNAMES=[]
VAR_AIDS_DETAIL_LIST_HOSTNAMES_DUPES=[]


for i in range (len(VAR_AIDS_DETAIL_LIST)):
    VAR_AIDS_DETAIL_LIST_HOSTNAMES.append((VAR_AIDS_DETAIL_LIST[i][0]))

VAR_AIDS_DETAIL_LIST_HOSTNAMES_DUPES=(list_duplicates(VAR_AIDS_DETAIL_LIST_HOSTNAMES))


print("DEBUG: Processing",VAR_AIDS_DETAIL_LIST_HOSTNAMES_DUPES,"dupes")

VAR_AIDS_DUPE=[]

for i in VAR_AIDS_DETAIL_LIST_HOSTNAMES_DUPES:
    count = 0
    for j in VAR_AIDS_DETAIL_LIST:
        print("DEBUG: Not storing ",i,j)
        if i in j:
            if count == 0:
                count += 1
                print("DEBUG: Not storing ",i,j)
            else:
                print("DEBUG: Storing ",i,j)
                VAR_AIDS_DUPE.append(j[1])


print("DEBUG: Hiding ",len(VAR_AIDS_DUPE),"Dupes")

print(VAR_AIDS_DUPE)
 
print("DEBUG: Sleeping for 5 seconds break now if you don't want to hide the ids")
time.sleep( 5 )


# WIP take the VAR_AID_TO_HIDE list and load it into example ( possible we can hide upto 2-5000 at a time .. not sure the limit ..):
# /devices/entities/devices-actions/v3?action_name=hide_host  -d '{"filter":"device_id:'################'"}'

r = requests.request("POST",'https://api.crowdstrike.com/devices/entities/devices-actions/v2?action_name=hide_host', headers = {'Authorization': 'Bearer ' + access_token,'Content-Type': 'application/json'},json={'ids': VAR_AIDS_DUPE},verify=VAR_SSL_FLAG)
print(r.text)



 

